# 抽象类

* 用abstract关键字来修饰一个类时，这个类叫做抽象类；用abstract来修饰一个方法时，该方法叫做抽象方法。
* 抽象方法：只有方法的声明，没有方法的实现。以分号结束：`abstract int abstractMethod( int a );`
* 含有抽象方法的类必须被声明为抽象类。
* 抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。
* 不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法，即abstract修饰**非私有的非静态**方法
* 比具体类范围更大
* 重写（实现implement）：把父类的抽象方法添加方法体
* 抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。

# 模板方法设计模式

1. 抽象类体现的就是一种模板模式的设计，**抽象类作为多个子类的通用模板**，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。
2. **解决的问题：**
   * 当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
   * 编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式。



# 接口

* **不同类型**事物的**共同行为**特征
* 接口与类平行
* 接口中**所有方法**都是**公共的抽象方法**，所有可以省略abstract和public，编译器会自动解析加上
* 接口中所有属性是**公共的静态的final量**（全局常量），可以省略static和final

* 接口不能被实例化，没有构造器
* 接口可以继承接口，并且可以多继承

# 代理模式：

* 把代理对象（中介）当作被代理对象（房东）使用
   * 1) 使用场景一, 无法直接创建被代理对象.
   * 2) 使用场景二, 要对被代理对象的方法进行增强. 但同时不能修改被代理类

# 抽象类与接口比较

| **No.** | **区别点**   | **抽象类**                                                   | **接口**                                    |
| ------- | ------------ | ------------------------------------------------------------ | ------------------------------------------- |
| 1       | 定义         | **对同一类不同种事物的抽象定义**                             | **不同类不同**种事物 的**共同的行为**的抽象 |
| 2       | 组成         | **比具体类多抽象方法**                                       | 全局常量(public static final)、抽象方法     |
| 3       | 使用         | 子类继承抽象类(extends)                                      | 子类实现接口(implements)                    |
| 4       | 关系         | 抽象类可以实现多个接口                                       | 接口不能继承抽象类，但允许继承多个接口      |
| 5       | 常见设计模式 | 模板设计                                                     | 工厂设计、代理设计                          |
| 6       | 对象         | 都通过对象的多态性产生实例化对象                             |                                             |
| 7       | 局限         | 抽象类有单继承的局限                                         | 接口没有此局限                              |
| 8       | 实际         | 作为一个模板                                                 | 是作为一个标准或是表示一种能力              |
| 9       | 选择         | 如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限 |                                             |
| 10      | 特殊         | 一个抽象类中可以实现多个接口，一个接口中可以包含多个抽象方法 |                                             |

# 工厂模式

面向接口, 不关注子类的具体类型

 * 场景1 : 创建对象复杂, 把创建对象的任务交给工厂
 * 场景2 : 通过工厂获取到的对象对于使用者来说不需要关注它的具体特征, 只需要关注对象实现了某接口足矣
